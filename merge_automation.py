#!/usr/bin/env python3
"""
Merge Automation Module
Auto-create merge requests for code fixes and improvements
"""

import os
import subprocess
import logging
from pathlib import Path
from typing import List, Optional, Dict
from github_automation import GitHubAPI, MergeRequest

logger = logging.getLogger(__name__)


class MergeAutomation:
    """Automate creation of merge requests for code improvements"""
    
    def __init__(self, github_token: Optional[str] = None, repo: Optional[str] = None):
        """Initialize merge automation"""
        self.github = GitHubAPI(github_token, repo)
        self.dry_run = os.getenv('DRY_RUN', 'false').lower() == 'true'
    
    def create_fix_branch(self, branch_name: str, base_branch: str = 'main') -> bool:
        """Create a new branch for fixes"""
        try:
            # Ensure we're on the base branch
            subprocess.run(['git', 'checkout', base_branch], check=True, capture_output=True)
            
            # Pull latest changes
            subprocess.run(['git', 'pull', 'origin', base_branch], check=True, capture_output=True)
            
            # Create new branch
            subprocess.run(['git', 'checkout', '-b', branch_name], check=True, capture_output=True)
            
            logger.info(f"Created new branch: {branch_name}")
            return True
            
        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to create branch {branch_name}: {e}")
            return False
    
    def commit_changes(self, message: str, files: Optional[List[str]] = None) -> bool:
        """Commit changes to current branch"""
        try:
            # Add files
            if files:
                for file in files:
                    subprocess.run(['git', 'add', file], check=True, capture_output=True)
            else:
                subprocess.run(['git', 'add', '.'], check=True, capture_output=True)
            
            # Check if there are any changes to commit
            result = subprocess.run(['git', 'diff', '--cached'], capture_output=True, text=True)
            if not result.stdout.strip():
                logger.info("No changes to commit")
                return False
            
            # Commit changes
            subprocess.run(['git', 'commit', '-m', message], check=True, capture_output=True)
            
            logger.info(f"Committed changes: {message}")
            return True
            
        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to commit changes: {e}")
            return False
    
    def push_branch(self, branch_name: str) -> bool:
        """Push branch to origin"""
        try:
            subprocess.run(['git', 'push', 'origin', branch_name], check=True, capture_output=True)
            logger.info(f"Pushed branch: {branch_name}")
            return True
            
        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to push branch {branch_name}: {e}")
            return False
    
    def auto_fix_shell_scripts(self) -> Optional[str]:
        """Automatically fix shell script issues and create PR"""
        branch_name = "auto-fix/shell-scripts-error-handling"
        
        if self.dry_run:
            logger.info(f"[DRY RUN] Would create branch {branch_name} and fix shell scripts")
            return None
        
        # Create branch
        if not self.create_fix_branch(branch_name):
            return None
        
        # Find and fix shell scripts
        fixed_files = []
        shell_scripts = list(Path('.').glob('**/*.sh'))
        
        for script in shell_scripts:
            if self._fix_shell_script(script):
                fixed_files.append(str(script))
        
        if not fixed_files:
            logger.info("No shell script fixes needed")
            return None
        
        # Commit changes
        commit_msg = f"Fix shell scripts: Add error handling (set -e) to {len(fixed_files)} scripts"
        if not self.commit_changes(commit_msg, fixed_files):
            return None
        
        # Push branch
        if not self.push_branch(branch_name):
            return None
        
        # Create pull request
        merge_request = MergeRequest(
            title="Auto-fix: Add error handling to shell scripts",
            description=f"""## Changes
This PR automatically adds proper error handling to shell scripts.

### Files Modified
{chr(10).join(f'- `{f}`' for f in fixed_files)}

### Improvements
- Added `set -e` to exit on errors
- Improved script reliability
- Addresses code quality audit findings

This is an automated fix generated by the PC Automation Tools.""",
            source_branch=branch_name,
            tags=["auto-fix", "shell-scripts", "code-quality"]
        )
        
        try:
            pr = self.github.create_pull_request(merge_request)
            logger.info(f"Created PR #{pr['number']}: {pr['title']}")
            return pr['html_url']
        except Exception as e:
            logger.error(f"Failed to create PR: {e}")
            return None
    
    def auto_fix_python_imports(self) -> Optional[str]:
        """Automatically fix Python import issues and create PR"""
        branch_name = "auto-fix/python-imports"
        
        if self.dry_run:
            logger.info(f"[DRY RUN] Would create branch {branch_name} and fix Python imports")
            return None
        
        # Create branch
        if not self.create_fix_branch(branch_name):
            return None
        
        # Find and fix Python files
        fixed_files = []
        python_files = list(Path('.').glob('**/*.py'))
        
        for py_file in python_files:
            if self._fix_python_imports(py_file):
                fixed_files.append(str(py_file))
        
        if not fixed_files:
            logger.info("No Python import fixes needed")
            return None
        
        # Commit changes
        commit_msg = f"Fix Python imports: Sort and organize imports in {len(fixed_files)} files"
        if not self.commit_changes(commit_msg, fixed_files):
            return None
        
        # Push branch
        if not self.push_branch(branch_name):
            return None
        
        # Create pull request
        merge_request = MergeRequest(
            title="Auto-fix: Organize Python imports",
            description=f"""## Changes
This PR automatically organizes and sorts Python imports according to PEP 8 standards.

### Files Modified
{chr(10).join(f'- `{f}`' for f in fixed_files)}

### Improvements
- Sorted imports alphabetically
- Separated standard library, third-party, and local imports
- Improved code readability
- Addresses code quality audit findings

This is an automated fix generated by the PC Automation Tools.""",
            source_branch=branch_name,
            tags=["auto-fix", "python", "imports", "code-quality"]
        )
        
        try:
            pr = self.github.create_pull_request(merge_request)
            logger.info(f"Created PR #{pr['number']}: {pr['title']}")
            return pr['html_url']
        except Exception as e:
            logger.error(f"Failed to create PR: {e}")
            return None
    
    def _fix_shell_script(self, script_path: Path) -> bool:
        """Fix a single shell script by adding error handling"""
        try:
            with open(script_path, 'r') as f:
                content = f.read()
            
            lines = content.split('\n')
            if not lines:
                return False
            
            # Check if already has set -e
            has_set_e = any('set -e' in line for line in lines[:10])
            if has_set_e:
                return False
            
            # Find shebang line
            shebang_idx = -1
            for i, line in enumerate(lines):
                if line.startswith('#!'):
                    shebang_idx = i
                    break
            
            if shebang_idx == -1:
                return False
            
            # Insert set -e after shebang
            lines.insert(shebang_idx + 1, 'set -e')
            
            # Write back
            with open(script_path, 'w') as f:
                f.write('\n'.join(lines))
            
            logger.info(f"Fixed shell script: {script_path}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to fix shell script {script_path}: {e}")
            return False
    
    def _fix_python_imports(self, py_file: Path) -> bool:
        """Fix Python imports in a file"""
        try:
            with open(py_file, 'r') as f:
                content = f.read()
            
            lines = content.split('\n')
            
            # Find import section
            import_start = -1
            import_end = -1
            
            for i, line in enumerate(lines):
                if line.startswith('import ') or line.startswith('from '):
                    if import_start == -1:
                        import_start = i
                    import_end = i
                elif import_start != -1 and line.strip() and not line.startswith('#'):
                    break
            
            if import_start == -1:
                return False
            
            # Extract and sort imports
            import_lines = lines[import_start:import_end + 1]
            
            # Separate different types of imports
            standard_imports = []
            third_party_imports = []
            local_imports = []
            
            for line in import_lines:
                if not line.strip() or line.startswith('#'):
                    continue
                
                # Simple heuristic for categorizing imports
                if any(lib in line for lib in ['os', 'sys', 'json', 'datetime', 'pathlib', 'subprocess']):
                    standard_imports.append(line)
                elif line.startswith('from .') or line.startswith('import .'):
                    local_imports.append(line)
                else:
                    third_party_imports.append(line)
            
            # Sort each category
            standard_imports.sort()
            third_party_imports.sort()
            local_imports.sort()
            
            # Combine with proper spacing
            new_imports = []
            if standard_imports:
                new_imports.extend(standard_imports)
                new_imports.append('')
            if third_party_imports:
                new_imports.extend(third_party_imports)
                new_imports.append('')
            if local_imports:
                new_imports.extend(local_imports)
                new_imports.append('')
            
            # Remove trailing empty line if it exists
            if new_imports and new_imports[-1] == '':
                new_imports.pop()
            
            # Check if changes are needed
            if new_imports == import_lines:
                return False
            
            # Replace import section
            new_lines = lines[:import_start] + new_imports + lines[import_end + 1:]
            
            # Write back
            with open(py_file, 'w') as f:
                f.write('\n'.join(new_lines))
            
            logger.info(f"Fixed Python imports: {py_file}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to fix Python imports {py_file}: {e}")
            return False
    
    def create_audit_fix_pr(self) -> List[str]:
        """Create PRs for all automatic fixes based on audit findings"""
        created_prs = []
        
        # Auto-fix shell scripts
        shell_pr = self.auto_fix_shell_scripts()
        if shell_pr:
            created_prs.append(shell_pr)
        
        # Auto-fix Python imports
        python_pr = self.auto_fix_python_imports()
        if python_pr:
            created_prs.append(python_pr)
        
        return created_prs


def main():
    """Main function for CLI usage"""
    import argparse
    
    parser = argparse.ArgumentParser(description='Auto-create merge requests for code fixes')
    parser.add_argument('--action', choices=['shell', 'python', 'all'], default='all',
                        help='Type of fixes to apply (default: all)')
    parser.add_argument('--dry-run', action='store_true',
                        help='Show what would be done without actually doing it')
    
    args = parser.parse_args()
    
    # Set dry run environment variable
    if args.dry_run:
        os.environ['DRY_RUN'] = 'true'
    
    automation = MergeAutomation()
    
    if args.action in ['shell', 'all']:
        logger.info("Creating shell script fixes...")
        automation.auto_fix_shell_scripts()
    
    if args.action in ['python', 'all']:
        logger.info("Creating Python import fixes...")
        automation.auto_fix_python_imports()
    
    logger.info("Merge automation completed!")


if __name__ == '__main__':
    main()