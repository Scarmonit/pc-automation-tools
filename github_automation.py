#!/usr/bin/env python3
"""
GitHub Automation Module
Auto-submit bugs and merge requests to GitHub repository
"""

import os
import json
import requests
import logging
from datetime import datetime
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from pathlib import Path

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


@dataclass
class BugReport:
    """Data class for bug reports"""
    title: str
    description: str
    severity: str = "medium"
    tags: List[str] = None
    file_path: Optional[str] = None
    line_number: Optional[int] = None
    
    def __post_init__(self):
        if self.tags is None:
            self.tags = []


@dataclass
class MergeRequest:
    """Data class for merge requests"""
    title: str
    description: str
    source_branch: str
    target_branch: str = "main"
    draft: bool = False
    tags: List[str] = None
    
    def __post_init__(self):
        if self.tags is None:
            self.tags = []


class GitHubAPI:
    """GitHub API client for automation"""
    
    def __init__(self, token: Optional[str] = None, repo: Optional[str] = None):
        """Initialize GitHub API client"""
        self.token = token or os.getenv('GITHUB_TOKEN')
        self.repo = repo or os.getenv('GITHUB_REPO', 'Scarmonit/pc-automation-tools')
        self.base_url = 'https://api.github.com'
        
        if not self.token:
            logger.warning("No GitHub token provided. Some operations may fail.")
        
        self.headers = {
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'PC-Automation-Tools'
        }
        
        if self.token:
            self.headers['Authorization'] = f'token {self.token}'
    
    def _make_request(self, method: str, endpoint: str, data: Optional[Dict] = None) -> Dict:
        """Make HTTP request to GitHub API"""
        url = f"{self.base_url}/{endpoint}"
        
        try:
            response = requests.request(
                method=method,
                url=url,
                headers=self.headers,
                json=data,
                timeout=30
            )
            response.raise_for_status()
            return response.json() if response.content else {}
            
        except requests.exceptions.RequestException as e:
            logger.error(f"GitHub API request failed: {e}")
            if hasattr(e, 'response') and e.response:
                logger.error(f"Response: {e.response.text}")
            raise
    
    def create_issue(self, bug_report: BugReport) -> Dict:
        """Create a GitHub issue for a bug report"""
        issue_body = f"""## Bug Description
{bug_report.description}

## Severity
{bug_report.severity.upper()}

## Location
"""
        
        if bug_report.file_path:
            issue_body += f"- **File:** `{bug_report.file_path}`\n"
        if bug_report.line_number:
            issue_body += f"- **Line:** {bug_report.line_number}\n"
        
        issue_body += f"""
## Auto-Generated Report
This issue was automatically generated by the PC Automation Tools audit system.

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
        
        # Add severity and bug labels
        labels = ['bug', f'severity-{bug_report.severity}'] + bug_report.tags
        
        issue_data = {
            'title': bug_report.title,
            'body': issue_body,
            'labels': labels
        }
        
        logger.info(f"Creating GitHub issue: {bug_report.title}")
        return self._make_request('POST', f'repos/{self.repo}/issues', issue_data)
    
    def create_pull_request(self, merge_request: MergeRequest) -> Dict:
        """Create a GitHub pull request"""
        pr_body = f"""## Description
{merge_request.description}

## Changes
Auto-generated pull request for code improvements and fixes.

## Auto-Generated Request
This pull request was automatically generated by the PC Automation Tools system.

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
        
        labels = ['enhancement'] + merge_request.tags
        
        pr_data = {
            'title': merge_request.title,
            'body': pr_body,
            'head': merge_request.source_branch,
            'base': merge_request.target_branch,
            'draft': merge_request.draft
        }
        
        logger.info(f"Creating GitHub pull request: {merge_request.title}")
        pr = self._make_request('POST', f'repos/{self.repo}/pulls', pr_data)
        
        # Add labels to the PR
        if labels:
            self._make_request('POST', f'repos/{self.repo}/issues/{pr["number"]}/labels', {'labels': labels})
        
        return pr
    
    def get_open_issues(self, labels: List[str] = None) -> List[Dict]:
        """Get open issues, optionally filtered by labels"""
        endpoint = f'repos/{self.repo}/issues'
        params = {'state': 'open'}
        
        if labels:
            params['labels'] = ','.join(labels)
        
        # Add params to URL
        if params:
            param_str = '&'.join([f"{k}={v}" for k, v in params.items()])
            endpoint += f"?{param_str}"
        
        return self._make_request('GET', endpoint)
    
    def check_issue_exists(self, title: str) -> bool:
        """Check if an issue with similar title already exists"""
        try:
            issues = self.get_open_issues()
            for issue in issues:
                if title.lower() in issue['title'].lower():
                    logger.info(f"Similar issue already exists: {issue['title']}")
                    return True
            return False
        except Exception as e:
            logger.warning(f"Could not check existing issues: {e}")
            return False


class AutoSubmitter:
    """Main automation class for submitting bugs and merges"""
    
    def __init__(self, github_token: Optional[str] = None, repo: Optional[str] = None):
        """Initialize the auto-submitter"""
        self.github = GitHubAPI(github_token, repo)
        self.config_file = Path('.env')
        self.dry_run = os.getenv('DRY_RUN', 'false').lower() == 'true'
    
    def submit_audit_bugs(self, audit_report_file: str = 'code_quality_audit_report.md') -> List[Dict]:
        """Submit bugs found in audit reports"""
        if not Path(audit_report_file).exists():
            logger.error(f"Audit report file not found: {audit_report_file}")
            return []
        
        bugs = self._parse_audit_report(audit_report_file)
        submitted_issues = []
        
        for bug in bugs:
            # Check if similar issue already exists
            if self.github.check_issue_exists(bug.title):
                logger.info(f"Skipping duplicate issue: {bug.title}")
                continue
            
            if self.dry_run:
                logger.info(f"[DRY RUN] Would create issue: {bug.title}")
                continue
            
            try:
                issue = self.github.create_issue(bug)
                submitted_issues.append(issue)
                logger.info(f"Created issue #{issue['number']}: {issue['title']}")
            except Exception as e:
                logger.error(f"Failed to create issue for {bug.title}: {e}")
        
        return submitted_issues
    
    def submit_security_bugs(self, security_report_file: str = 'security_audit_report.md') -> List[Dict]:
        """Submit security issues found in security audit"""
        if not Path(security_report_file).exists():
            logger.error(f"Security report file not found: {security_report_file}")
            return []
        
        bugs = self._parse_security_report(security_report_file)
        submitted_issues = []
        
        for bug in bugs:
            if self.github.check_issue_exists(bug.title):
                logger.info(f"Skipping duplicate security issue: {bug.title}")
                continue
            
            if self.dry_run:
                logger.info(f"[DRY RUN] Would create security issue: {bug.title}")
                continue
            
            try:
                issue = self.github.create_issue(bug)
                submitted_issues.append(issue)
                logger.info(f"Created security issue #{issue['number']}: {issue['title']}")
            except Exception as e:
                logger.error(f"Failed to create security issue for {bug.title}: {e}")
        
        return submitted_issues
    
    def _parse_audit_report(self, report_file: str) -> List[BugReport]:
        """Parse code quality audit report to extract bugs"""
        bugs = []
        
        try:
            with open(report_file, 'r') as f:
                content = f.read()
            
            # Parse the markdown report to extract issues
            lines = content.split('\n')
            current_issue = None
            
            for i, line in enumerate(lines):
                # Look for issue entries like "**1. Shell Scripts**"
                if line.startswith('**') and line.endswith('**') and '. ' in line:
                    # Check if next line has description
                    if i + 1 < len(lines) and lines[i + 1].startswith('- Description:'):
                        if current_issue:
                            bugs.append(current_issue)
                        
                        # Extract description from next line
                        desc_line = lines[i + 1]
                        desc = desc_line.split('Description:', 1)[1].strip()
                        
                        current_issue = BugReport(
                            title=f"Code Quality: {desc}",
                            description=desc,
                            severity="medium",
                            tags=["code-quality", "auto-generated"]
                        )
                
                elif current_issue and line.startswith('- File:'):
                    # Extract file path - remove backticks
                    file_path = line.split('File:', 1)[1].strip().strip('`')
                    current_issue.file_path = file_path
                
                elif current_issue and line.startswith('- Line:'):
                    # Extract line number
                    try:
                        line_num = int(line.split('Line:', 1)[1].strip())
                        current_issue.line_number = line_num
                    except ValueError:
                        pass
            
            # Add the last issue if exists
            if current_issue:
                bugs.append(current_issue)
        
        except Exception as e:
            logger.error(f"Failed to parse audit report: {e}")
        
        return bugs
    
    def _parse_security_report(self, report_file: str) -> List[BugReport]:
        """Parse security audit report to extract security issues"""
        bugs = []
        
        try:
            with open(report_file, 'r') as f:
                content = f.read()
            
            # Parse security issues (similar to audit report but with higher severity)
            lines = content.split('\n')
            current_issue = None
            current_severity = "medium"
            
            for i, line in enumerate(lines):
                # Detect severity sections
                if '### HIGH Severity' in line:
                    current_severity = "high"
                elif '### MEDIUM Severity' in line:
                    current_severity = "medium"
                elif '### LOW Severity' in line:
                    current_severity = "low"
                
                # Look for issue entries like "**1. Hardcoded Secrets**"
                elif line.startswith('**') and line.endswith('**') and '. ' in line:
                    # Check if next line has description
                    if i + 1 < len(lines) and lines[i + 1].startswith('- Description:'):
                        if current_issue:
                            bugs.append(current_issue)
                        
                        # Extract description from next line
                        desc_line = lines[i + 1]
                        desc = desc_line.split('Description:', 1)[1].strip()
                        
                        current_issue = BugReport(
                            title=f"Security: {desc}",
                            description=desc,
                            severity=current_severity,
                            tags=["security", "auto-generated"]
                        )
                
                elif current_issue and line.startswith('- File:'):
                    # Extract file path - remove backticks
                    file_path = line.split('File:', 1)[1].strip().strip('`')
                    current_issue.file_path = file_path
                
                elif current_issue and line.startswith('- Line:'):
                    # Extract line number
                    try:
                        line_num = int(line.split('Line:', 1)[1].strip())
                        current_issue.line_number = line_num
                    except ValueError:
                        pass
            
            if current_issue:
                bugs.append(current_issue)
        
        except Exception as e:
            logger.error(f"Failed to parse security report: {e}")
        
        return bugs


def main():
    """Main function for CLI usage"""
    import argparse
    
    parser = argparse.ArgumentParser(description='Auto-submit bugs and merge requests to GitHub')
    parser.add_argument('--action', choices=['bugs', 'security', 'both'], default='both',
                        help='Action to perform (default: both)')
    parser.add_argument('--dry-run', action='store_true',
                        help='Show what would be done without actually doing it')
    parser.add_argument('--audit-report', default='code_quality_audit_report.md',
                        help='Path to audit report file')
    parser.add_argument('--security-report', default='security_audit_report.md',
                        help='Path to security report file')
    
    args = parser.parse_args()
    
    # Set dry run environment variable
    if args.dry_run:
        os.environ['DRY_RUN'] = 'true'
    
    submitter = AutoSubmitter()
    
    if args.action in ['bugs', 'both']:
        logger.info("Submitting code quality bugs...")
        submitter.submit_audit_bugs(args.audit_report)
    
    if args.action in ['security', 'both']:
        logger.info("Submitting security bugs...")
        submitter.submit_security_bugs(args.security_report)
    
    logger.info("Auto-submission completed!")


if __name__ == '__main__':
    main()