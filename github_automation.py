#!/usr/bin/env python3
"""
GitHub Automation Module
Auto-submit bugs and merge requests to GitHub repository
"""

import os
import json
import requests
import logging
from datetime import datetime
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from pathlib import Path

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


@dataclass
class BugReport:
    """Data class for bug reports"""
    title: str
    description: str
    severity: str = "medium"
    tags: List[str] = None
    file_path: Optional[str] = None
    line_number: Optional[int] = None
    
    def __post_init__(self):
        if self.tags is None:
            self.tags = []


@dataclass
class MergeRequest:
    """Data class for merge requests"""
    title: str
    description: str
    source_branch: str
    target_branch: str = "main"
    draft: bool = False
    tags: List[str] = None
    
    def __post_init__(self):
        if self.tags is None:
            self.tags = []


@dataclass
class ReviewRequest:
    """Data class for pull request reviews"""
    pr_number: int
    event: str  # 'APPROVE', 'REQUEST_CHANGES', 'COMMENT'
    body: str = ""
    comments: List[Dict] = None  # Line-specific comments
    
    def __post_init__(self):
        if self.comments is None:
            self.comments = []


class GitHubAPI:
    """GitHub API client for automation"""
    
    def __init__(self, token: Optional[str] = None, repo: Optional[str] = None):
        """Initialize GitHub API client"""
        self.token = token or os.getenv('GITHUB_TOKEN')
        self.repo = repo or os.getenv('GITHUB_REPO', 'Scarmonit/pc-automation-tools')
        self.base_url = 'https://api.github.com'
        
        if not self.token:
            logger.warning("No GitHub token provided. Some operations may fail.")
        
        self.headers = {
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'PC-Automation-Tools'
        }
        
        if self.token:
            self.headers['Authorization'] = f'token {self.token}'
    
    def _make_request(self, method: str, endpoint: str, data: Optional[Dict] = None) -> Dict:
        """Make HTTP request to GitHub API"""
        url = f"{self.base_url}/{endpoint}"
        
        try:
            response = requests.request(
                method=method,
                url=url,
                headers=self.headers,
                json=data,
                timeout=30
            )
            response.raise_for_status()
            return response.json() if response.content else {}
            
        except requests.exceptions.RequestException as e:
            logger.error(f"GitHub API request failed: {e}")
            if hasattr(e, 'response') and e.response:
                logger.error(f"Response: {e.response.text}")
            raise
    
    def create_issue(self, bug_report: BugReport) -> Dict:
        """Create a GitHub issue for a bug report"""
        issue_body = f"""## Bug Description
{bug_report.description}

## Severity
{bug_report.severity.upper()}

## Location
"""
        
        if bug_report.file_path:
            issue_body += f"- **File:** `{bug_report.file_path}`\n"
        if bug_report.line_number:
            issue_body += f"- **Line:** {bug_report.line_number}\n"
        
        issue_body += f"""
## Auto-Generated Report
This issue was automatically generated by the PC Automation Tools audit system.

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
        
        # Add severity and bug labels
        labels = ['bug', f'severity-{bug_report.severity}'] + bug_report.tags
        
        issue_data = {
            'title': bug_report.title,
            'body': issue_body,
            'labels': labels
        }
        
        logger.info(f"Creating GitHub issue: {bug_report.title}")
        return self._make_request('POST', f'repos/{self.repo}/issues', issue_data)
    
    def create_pull_request(self, merge_request: MergeRequest) -> Dict:
        """Create a GitHub pull request"""
        pr_body = f"""## Description
{merge_request.description}

## Changes
Auto-generated pull request for code improvements and fixes.

## Auto-Generated Request
This pull request was automatically generated by the PC Automation Tools system.

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
        
        labels = ['enhancement'] + merge_request.tags
        
        pr_data = {
            'title': merge_request.title,
            'body': pr_body,
            'head': merge_request.source_branch,
            'base': merge_request.target_branch,
            'draft': merge_request.draft
        }
        
        logger.info(f"Creating GitHub pull request: {merge_request.title}")
        pr = self._make_request('POST', f'repos/{self.repo}/pulls', pr_data)
        
        # Add labels to the PR
        if labels:
            self._make_request('POST', f'repos/{self.repo}/issues/{pr["number"]}/labels', {'labels': labels})
        
        return pr
    
    def get_open_issues(self, labels: List[str] = None) -> List[Dict]:
        """Get open issues, optionally filtered by labels"""
        endpoint = f'repos/{self.repo}/issues'
        params = {'state': 'open'}
        
        if labels:
            params['labels'] = ','.join(labels)
        
        # Add params to URL
        if params:
            param_str = '&'.join([f"{k}={v}" for k, v in params.items()])
            endpoint += f"?{param_str}"
        
        return self._make_request('GET', endpoint)
    
    def check_issue_exists(self, title: str) -> bool:
        """Check if an issue with similar title already exists"""
        try:
            issues = self.get_open_issues()
            for issue in issues:
                if title.lower() in issue['title'].lower():
                    logger.info(f"Similar issue already exists: {issue['title']}")
                    return True
            return False
        except Exception as e:
            logger.warning(f"Could not check existing issues: {e}")
            return False
    
    def get_open_pull_requests(self) -> List[Dict]:
        """Get open pull requests"""
        endpoint = f'repos/{self.repo}/pulls'
        params = {'state': 'open'}
        param_str = '&'.join([f"{k}={v}" for k, v in params.items()])
        endpoint += f"?{param_str}"
        
        return self._make_request('GET', endpoint)
    
    def get_pull_request_files(self, pr_number: int) -> List[Dict]:
        """Get files changed in a pull request"""
        endpoint = f'repos/{self.repo}/pulls/{pr_number}/files'
        return self._make_request('GET', endpoint)
    
    def submit_review(self, review_request: ReviewRequest) -> Dict:
        """Submit a review on a pull request"""
        review_body = f"""## Automated Code Review

{review_request.body}

## Auto-Generated Review
This review was automatically generated by the PC Automation Tools system.

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
        
        review_data = {
            'event': review_request.event,
            'body': review_body
        }
        
        # Add line-specific comments if provided
        if review_request.comments:
            review_data['comments'] = review_request.comments
        
        logger.info(f"Submitting {review_request.event} review on PR #{review_request.pr_number}")
        return self._make_request('POST', f'repos/{self.repo}/pulls/{review_request.pr_number}/reviews', review_data)


class AutoSubmitter:
    """Main automation class for submitting bugs and merges"""
    
    def __init__(self, github_token: Optional[str] = None, repo: Optional[str] = None):
        """Initialize the auto-submitter"""
        self.github = GitHubAPI(github_token, repo)
        self.config_file = Path('.env')
        self.dry_run = os.getenv('DRY_RUN', 'false').lower() == 'true'
    
    def submit_audit_bugs(self, audit_report_file: str = 'code_quality_audit_report.md') -> List[Dict]:
        """Submit bugs found in audit reports"""
        if not Path(audit_report_file).exists():
            logger.error(f"Audit report file not found: {audit_report_file}")
            return []
        
        bugs = self._parse_audit_report(audit_report_file)
        submitted_issues = []
        
        for bug in bugs:
            # Check if similar issue already exists
            if self.github.check_issue_exists(bug.title):
                logger.info(f"Skipping duplicate issue: {bug.title}")
                continue
            
            if self.dry_run:
                logger.info(f"[DRY RUN] Would create issue: {bug.title}")
                continue
            
            try:
                issue = self.github.create_issue(bug)
                submitted_issues.append(issue)
                logger.info(f"Created issue #{issue['number']}: {issue['title']}")
            except Exception as e:
                logger.error(f"Failed to create issue for {bug.title}: {e}")
        
        return submitted_issues
    
    def submit_security_bugs(self, security_report_file: str = 'security_audit_report.md') -> List[Dict]:
        """Submit security issues found in security audit"""
        if not Path(security_report_file).exists():
            logger.error(f"Security report file not found: {security_report_file}")
            return []
        
        bugs = self._parse_security_report(security_report_file)
        submitted_issues = []
        
        for bug in bugs:
            if self.github.check_issue_exists(bug.title):
                logger.info(f"Skipping duplicate security issue: {bug.title}")
                continue
            
            if self.dry_run:
                logger.info(f"[DRY RUN] Would create security issue: {bug.title}")
                continue
            
            try:
                issue = self.github.create_issue(bug)
                submitted_issues.append(issue)
                logger.info(f"Created security issue #{issue['number']}: {issue['title']}")
            except Exception as e:
                logger.error(f"Failed to create security issue for {bug.title}: {e}")
        
        return submitted_issues
    
    def _parse_audit_report(self, report_file: str) -> List[BugReport]:
        """Parse code quality audit report to extract bugs"""
        bugs = []
        
        try:
            with open(report_file, 'r') as f:
                content = f.read()
            
            # Parse the markdown report to extract issues
            lines = content.split('\n')
            current_issue = None
            
            for i, line in enumerate(lines):
                # Look for issue entries like "**1. Shell Scripts**"
                if line.startswith('**') and line.endswith('**') and '. ' in line:
                    # Check if next line has description
                    if i + 1 < len(lines) and lines[i + 1].startswith('- Description:'):
                        if current_issue:
                            bugs.append(current_issue)
                        
                        # Extract description from next line
                        desc_line = lines[i + 1]
                        desc = desc_line.split('Description:', 1)[1].strip()
                        
                        current_issue = BugReport(
                            title=f"Code Quality: {desc}",
                            description=desc,
                            severity="medium",
                            tags=["code-quality", "auto-generated"]
                        )
                
                elif current_issue and line.startswith('- File:'):
                    # Extract file path - remove backticks
                    file_path = line.split('File:', 1)[1].strip().strip('`')
                    current_issue.file_path = file_path
                
                elif current_issue and line.startswith('- Line:'):
                    # Extract line number
                    try:
                        line_num = int(line.split('Line:', 1)[1].strip())
                        current_issue.line_number = line_num
                    except ValueError:
                        pass
            
            # Add the last issue if exists
            if current_issue:
                bugs.append(current_issue)
        
        except Exception as e:
            logger.error(f"Failed to parse audit report: {e}")
        
        return bugs
    
    def _parse_security_report(self, report_file: str) -> List[BugReport]:
        """Parse security audit report to extract security issues"""
        bugs = []
        
        try:
            with open(report_file, 'r') as f:
                content = f.read()
            
            # Parse security issues (similar to audit report but with higher severity)
            lines = content.split('\n')
            current_issue = None
            current_severity = "medium"
            
            for i, line in enumerate(lines):
                # Detect severity sections
                if '### HIGH Severity' in line:
                    current_severity = "high"
                elif '### MEDIUM Severity' in line:
                    current_severity = "medium"
                elif '### LOW Severity' in line:
                    current_severity = "low"
                
                # Look for issue entries like "**1. Hardcoded Secrets**"
                elif line.startswith('**') and line.endswith('**') and '. ' in line:
                    # Check if next line has description
                    if i + 1 < len(lines) and lines[i + 1].startswith('- Description:'):
                        if current_issue:
                            bugs.append(current_issue)
                        
                        # Extract description from next line
                        desc_line = lines[i + 1]
                        desc = desc_line.split('Description:', 1)[1].strip()
                        
                        current_issue = BugReport(
                            title=f"Security: {desc}",
                            description=desc,
                            severity=current_severity,
                            tags=["security", "auto-generated"]
                        )
                
                elif current_issue and line.startswith('- File:'):
                    # Extract file path - remove backticks
                    file_path = line.split('File:', 1)[1].strip().strip('`')
                    current_issue.file_path = file_path
                
                elif current_issue and line.startswith('- Line:'):
                    # Extract line number
                    try:
                        line_num = int(line.split('Line:', 1)[1].strip())
                        current_issue.line_number = line_num
                    except ValueError:
                        pass
            
            if current_issue:
                bugs.append(current_issue)
        
        except Exception as e:
            logger.error(f"Failed to parse security report: {e}")
        
        return bugs
    
    def submit_automated_reviews(self) -> List[Dict]:
        """Submit automated reviews on open pull requests"""
        try:
            prs = self.github.get_open_pull_requests()
            submitted_reviews = []
            
            for pr in prs:
                # Skip draft PRs and PRs from automation
                if pr.get('draft', False):
                    logger.info(f"Skipping draft PR #{pr['number']}: {pr['title']}")
                    continue
                
                # Skip PRs that are already reviewed or created by automation
                if any(tag in pr['title'].lower() for tag in ['auto-generated', 'automated', 'bot']):
                    logger.info(f"Skipping automated PR #{pr['number']}: {pr['title']}")
                    continue
                
                review = self._analyze_pull_request(pr)
                if not review:
                    continue
                
                if self.dry_run:
                    logger.info(f"[DRY RUN] Would submit {review.event} review on PR #{pr['number']}")
                    continue
                
                try:
                    submitted_review = self.github.submit_review(review)
                    submitted_reviews.append(submitted_review)
                    logger.info(f"Submitted {review.event} review on PR #{pr['number']}: {pr['title']}")
                except Exception as e:
                    logger.error(f"Failed to submit review on PR #{pr['number']}: {e}")
            
            return submitted_reviews
            
        except Exception as e:
            logger.error(f"Failed to submit automated reviews: {e}")
            return []
    
    def _analyze_pull_request(self, pr: Dict) -> Optional[ReviewRequest]:
        """Analyze a pull request and determine if it needs an automated review"""
        try:
            pr_number = pr['number']
            files = self.github.get_pull_request_files(pr_number)
            
            # Simple analysis for demonstration
            # In a real implementation, this would contain more sophisticated logic
            
            issues = []
            security_concerns = []
            
            for file in files:
                filename = file['filename']
                patch = file.get('patch', '')
                
                # Check for potential security issues
                if '.sh' in filename and 'set -e' not in patch and '#!/bin/bash' in patch:
                    security_concerns.append(f"Shell script {filename} may be missing error handling")
                
                # Check for code quality issues  
                if '.py' in filename and 'import os' in patch and 'subprocess' in patch:
                    issues.append(f"Python file {filename} uses both os and subprocess - consider consolidating")
                
                # Check for missing documentation
                if filename == 'README.md' and len(patch.split('\n')) < 5:
                    issues.append("README changes are minimal - consider adding more documentation")
            
            # Determine review type based on findings
            if security_concerns:
                body = "## Security Concerns Found\n\n" + "\n".join(f"- {concern}" for concern in security_concerns)
                if issues:
                    body += "\n\n## Additional Issues\n\n" + "\n".join(f"- {issue}" for issue in issues)
                body += "\n\nPlease address these security concerns before merging."
                return ReviewRequest(pr_number=pr_number, event='REQUEST_CHANGES', body=body)
            
            elif issues:
                body = "## Code Quality Suggestions\n\n" + "\n".join(f"- {issue}" for issue in issues)
                body += "\n\nThese are suggestions for improvement but not blocking issues."
                return ReviewRequest(pr_number=pr_number, event='COMMENT', body=body)
            
            else:
                # If no issues found, approve simple changes
                if len(files) <= 3 and all(file['changes'] <= 20 for file in files):
                    body = "Automated review completed. No issues found in this small change set."
                    return ReviewRequest(pr_number=pr_number, event='APPROVE', body=body)
            
            return None
            
        except Exception as e:
            logger.error(f"Failed to analyze PR #{pr.get('number', 'unknown')}: {e}")
            return None


def main():
    """Main function for CLI usage"""
    import argparse
    
    parser = argparse.ArgumentParser(description='Auto-submit bugs and merge requests to GitHub')
    parser.add_argument('--action', choices=['bugs', 'security', 'reviews', 'all'], default='all',
                        help='Action to perform (default: all)')
    parser.add_argument('--dry-run', action='store_true',
                        help='Show what would be done without actually doing it')
    parser.add_argument('--audit-report', default='code_quality_audit_report.md',
                        help='Path to audit report file')
    parser.add_argument('--security-report', default='security_audit_report.md',
                        help='Path to security report file')
    
    args = parser.parse_args()
    
    # Set dry run environment variable
    if args.dry_run:
        os.environ['DRY_RUN'] = 'true'
    
    submitter = AutoSubmitter()
    
    if args.action in ['bugs', 'all']:
        logger.info("Submitting code quality bugs...")
        submitter.submit_audit_bugs(args.audit_report)
    
    if args.action in ['security', 'all']:
        logger.info("Submitting security bugs...")
        submitter.submit_security_bugs(args.security_report)
    
    if args.action in ['reviews', 'all']:
        logger.info("Submitting automated reviews...")
        submitter.submit_automated_reviews()
    
    logger.info("Auto-submission completed!")


if __name__ == '__main__':
    main()